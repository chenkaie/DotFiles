/*
 *******************************************************************************
 * $Header: $
 *
 *  Copyright (c) 2006 Vivotek Inc. All rights reserved.
 *
 *  +-----------------------------------------------------------------+
 *  | THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED |
 *  | AND COPIED IN ACCORDANCE WITH THE TERMS AND CONDITIONS OF SUCH  |
 *  | A LICENSE AND WITH THE INCLUSION OF THE THIS COPY RIGHT NOTICE. |
 *  | THIS SOFTWARE OR ANY OTHER COPIES OF THIS SOFTWARE MAY NOT BE   |
 *  | PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON. THE   |
 *  | OWNERSHIP AND TITLE OF THIS SOFTWARE IS NOT TRANSFERRED.        |
 *  |                                                                 |
 *  | THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT   |
 *  | ANY PRIOR NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY |
 *  | VIVOTEK INC.                                                    |
 *  +-----------------------------------------------------------------+
 *
 * $History: $
 * 
 *******************************************************************************
 */


#include <string.h>
#include <stdlib.h>
#include <sys/syslog.h>
#include "cs_action.h"
#include "escapedecodestring.h"

int GetNameValue(char **ppszSrc, char *pszName, char *pszValue)
{
	char	*psz0;
	char	*psz1;
	DWORD	dwInputValLen = 0;
	DWORD	dwOutputValLen = 0;

	psz0 = *ppszSrc;
	if (*psz0)
	{
		psz1 = strstr(psz0, "=");
		//printf(" psz1 : %s\n", psz1);
		if (psz1)
		{
			strncpy(pszName, psz0, psz1 - psz0);
			pszName[psz1 - psz0] = 0;
			psz0 = psz1 + 1;
			psz1 = strstr(psz0, "&");
			if (psz1)
			{
				strncpy(pszValue, psz0, psz1-psz0);
				pszValue[psz1 - psz0] = 0;
				*ppszSrc = psz1 + 1;
			}
			else
			{
				strcpy(pszValue, psz0);
				*ppszSrc = psz0 + strlen(pszValue);
			}

			dwInputValLen = strlen(pszValue);
			// Decode string
			EscapeDecodeString(pszValue, dwInputValLen, pszValue, &dwOutputValLen, TRUE);
			return 0;
		}
	}
	return -1;
}

int ParseParamFromCGI(TCSInfo *pi)
{
	char	*pszParam;
	char	*psz = NULL;
	char	*pszcl;
	char	szName[64];
	char	szValue[64];
	int	integer = 0;

	pszcl = getenv("CONTENT_LENGTH");
	if (pszcl)
	{
		integer = atoi(pszcl);
		pszParam = malloc(integer);
	}
	else if((pszParam = getenv("QUERY_STRING")) != NULL)
	{
		psz = pszParam;
	}
	else
	{
		printf("getenv error\n");
		//psz = "_a=1&_s=1&_p=1&_i=1&_t=ipv4";	// add to deny list
		//psz = "_l=1";				// list connection status
		//psz = "_a=3";				// disconnect all connections
		//disconnect several connections
		//psz = "_a=2&_s=185652&_p=0&_i=1&_t=ipv4&_r=172.16.2.52&_s=185759&_p=0&_i=1&_t=ipv4&_r=172.16.2.44";
		return -1;
	}
	
	if (psz)
	{
		//GET method
	}
	else
	{
		//POST method
        int iLen = 0;
		if((iLen =fread(pszParam, 1, integer, stdin)) != integer)
		{
			//the input might be escape decoded
             pszParam[iLen] = '\0';
		}
		psz = pszParam;
	}
	
	while (1)
	{
		if (GetNameValue(&psz, szValue, szName))
		{
			//printf("Get Name Value fail\n");
			break;
		}
		if (szValue[0] == '_')
		{
			switch (szValue[1])
			{
				case 'l':
					ListFiles(pi);
					break;
				case 'a':	//(1)add to deny list  (2)disconnect
					pi->eConnAct = atoi(szName);
					//printf("\t Action = %d\n", pi->eConnAct);
					if (
						(pi->eConnAct == eDisconnectAll) ||
						(pi->eConnAct == eDisconnectRtspAll) ||
						(pi->eConnAct == eDisconnectSvrpshAll) )
					{
						ConnectManager(pi);
					}
					break;
				case 's':	//record session id
					strcpy(pi->szSessionID, szName);
					//printf("\t Session ID = %s\n", pi->szSessionID);
					break;
				case 'p':	//(0)RTSP  (1)ServerPush
					pi->eProtocol = atoi(szName);
					//printf("\t Protocol = %d\n", pi->eProtocol);
					break;
				case 'i':
					strncpy(pi->szIndex, szName, MAX_PRARM_LEN);
					ConnectManager(pi);
					break;
				case 'm':
					printf("Content-type: text/html\n\n<meta http-equiv=refresh content=\"0;URL=/%s\">", szName);
					break;
				default:
					break;
			}
		}
	}
	if ((pszcl) && (pszParam != NULL))
	{
		free(pszParam);
	}
	return 0;
}
