!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.6	//
BuildContextStack	namespaces.vim	/^function! s:BuildContextStack(namespaces, szCurrentScope)$/;"	f
CACHE_OVERLOADED_FUNCTIONS	complete.vim	/^let s:CACHE_OVERLOADED_FUNCTIONS = {}$/;"	v
CACHE_TAG_ENV	complete.vim	/^let s:CACHE_TAG_ENV = ''$/;"	v
CACHE_TAG_FILES	complete.vim	/^let s:CACHE_TAG_FILES = {}$/;"	v
CACHE_TAG_POPUP_ITEMS	complete.vim	/^let s:CACHE_TAG_POPUP_ITEMS = {}$/;"	v
CanUseOmnicompletion	maycomplete.vim	/^function! s:CanUseOmnicompletion()$/;"	f
DisplayIncludeTree	includes.vim	/^function! s:DisplayIncludeTree(szFilePath, indent, ...)$/;"	f
ExtendTagItemToPopupItem	complete.vim	/^function! s:ExtendTagItemToPopupItem(tagItem, szTypeName)$/;"	f
ExtractScopeFromTypeInfo	utils.vim	/^function! s:ExtractScopeFromTypeInfo(szTypeInfo)$/;"	f
ExtractTypeInfoFromDecl	items.vim	/^function! s:ExtractTypeInfoFromDecl(tokens)$/;"	f
FilterClassMembers	complete.vim	/^function! s:FilterClassMembers(tagPopupList, szAccessFilter)$/;"	f
FilterClassScopeMembers	complete.vim	/^function! s:FilterClassScopeMembers(tagPopupList, szAccessFilter)$/;"	f
FilterNamespaceScopeMembers	complete.vim	/^function! s:FilterNamespaceScopeMembers(tagPopupList)$/;"	f
FilterOverloadedFunctions	complete.vim	/^function! s:FilterOverloadedFunctions(tagPopupList)$/;"	f
FilterStaticClassMembers	complete.vim	/^function! s:FilterStaticClassMembers(tagPopupList, szAccessFilter)$/;"	f
FindStartPositionOfCompletion	complete.vim	/^function! s:FindStartPositionOfCompletion()$/;"	f
GetAccessFilter	complete.vim	/^function! s:GetAccessFilter(szFilter, szAccessFilter)$/;"	f
GetAllUsingNamespaceMapFromCurrentBuffer	namespaces.vim	/^function! s:GetAllUsingNamespaceMapFromCurrentBuffer(...)$/;"	f
GetAllUsingNamespaceMapFromFile	namespaces.vim	/^function! s:GetAllUsingNamespaceMapFromFile(szFilePath, ...)$/;"	f
GetClassScopeAtCursor	namespaces.vim	/^function! s:GetClassScopeAtCursor()$/;"	f
GetIncludeListFromCurrentBuffer	includes.vim	/^function! s:GetIncludeListFromCurrentBuffer()$/;"	f
GetIncludeListFromFile	includes.vim	/^function! s:GetIncludeListFromFile(szFilePath, bUpdate) $/;"	f
GetNamespaceAliasListFromLine	namespaces.vim	/^function! s:GetNamespaceAliasListFromLine(szLine)$/;"	f
GetNamespaceAliasMap	namespaces.vim	/^function! s:GetNamespaceAliasMap()$/;"	f
GetNamespaceListFromLine	namespaces.vim	/^function! s:GetNamespaceListFromLine(szLine)$/;"	f
GetStopPositionForLocalSearch	namespaces.vim	/^function! s:GetStopPositionForLocalSearch()$/;"	f
GetSymbol	items.vim	/^function! s:GetSymbol(tokens)$/;"	f
GetTagOfSameScope	utils.vim	/^function! s:GetTagOfSameScope(listTags, szScopeToMatch)$/;"	f
GetTypeInfoOfReturnedType	items.vim	/^function! s:GetTypeInfoOfReturnedType(contextStack, szFunctionName)$/;"	f
GetTypeInfoOfVariable	items.vim	/^function! s:GetTypeInfoOfVariable(contextStack, szVariable, bSearchDecl)$/;"	f
GetUsingNamespaceListFromMap	namespaces.vim	/^function! s:GetUsingNamespaceListFromMap(namespaceMap, ...)$/;"	f
HasATagFileOrTagEnvChanged	complete.vim	/^function! s:HasATagFileOrTagEnvChanged()$/;"	f
HasTagEnvChanged	complete.vim	/^function! s:HasTagEnvChanged()$/;"	f
InitComplete	complete.vim	/^function! s:InitComplete()$/;"	f
IsCached	complete.vim	/^function! s:IsCached(cache, szKey1, szKey2)$/;"	f
IsTypeInfoResolved	utils.vim	/^function! s:IsTypeInfoResolved(szTypeInfo)$/;"	f
IsUnnamedType	items.vim	/^function! s:IsUnnamedType(tagItem)$/;"	f
LocalSearchDecl	items.vim	/^function! s:LocalSearchDecl(name)$/;"	f
OmniCpp_ShowAccess	complete.vim	/^let s:OmniCpp_ShowAccess = g:OmniCpp_ShowAccess$/;"	v
OmniCpp_ShowPrototypeInAbbr	complete.vim	/^let s:OmniCpp_ShowPrototypeInAbbr = g:OmniCpp_ShowPrototypeInAbbr$/;"	v
OmniCpp_ShowScopeInAbbr	complete.vim	/^let s:OmniCpp_ShowScopeInAbbr = g:OmniCpp_ShowScopeInAbbr$/;"	v
RemoveCComments	utils.vim	/^function! s:RemoveCComments(szLine)$/;"	f
ResolveAliasInNamespaceList	namespaces.vim	/^function! s:ResolveAliasInNamespaceList(mapNamespaceAlias, listNamespaces)$/;"	f
ResolveAliasKey	namespaces.vim	/^function! s:ResolveAliasKey(mapNamespaceAlias, szAlias)$/;"	f
ResolveAliasKeys	namespaces.vim	/^function! s:ResolveAliasKeys(mapNamespaceAlias)$/;"	f
ResolveCCast	items.vim	/^function! s:ResolveCCast(tokens)$/;"	f
ResolveCast	items.vim	/^function! s:ResolveCast(tokens, startChar, endChar)$/;"	f
ResolveCppCast	items.vim	/^function! s:ResolveCppCast(tokens)$/;"	f
ResolveNamespace	namespaces.vim	/^function! s:ResolveNamespace(namespace, mapCurrentContexts)$/;"	f
ResolveSymbol	items.vim	/^function! s:ResolveSymbol(contextStack, szSymbol, szTagFilter)$/;"	f
SearchDecl	items.vim	/^function! s:SearchDecl(szVariable)$/;"	f
SearchGlobalMembers	complete.vim	/^function! s:SearchGlobalMembers(szBase)$/;"	f
SearchMembers	complete.vim	/^function! s:SearchMembers(resolvedTagItem, szBase)$/;"	f
SearchTypeInfoOfDecl	items.vim	/^function! s:SearchTypeInfoOfDecl(szVariable)$/;"	f
TagPopupList	complete.vim	/^function! s:TagPopupList(szTypeName, szBase)$/;"	f
TokensToString	items.vim	/^function! s:TokensToString(tokens)$/;"	f
aPos	namespaces.vim	/^        let aPos = matchend(code.code, '::\\s*\\~*\\s*\\w\\+\\s*(')$/;"	v
bDoNotComplete	complete.vim	/^    let s:bDoNotComplete = 0$/;"	v
bMayComplete	complete.vim	/^let s:bMayComplete = 0$/;"	v
bResolved	namespaces.vim	/^                let bResolved = 1$/;"	v
cppKeyword	tokenizer.vim	/^let s:cppKeyword = ['asm', 'auto', 'bool', 'break', 'case', 'catch', 'char', 'class', 'const', 'const_cast', 'continue', 'default', 'delete', 'do', 'double', 'dynamic_cast', 'else', 'enum', 'explicit', 'export', 'extern', 'false', 'float', 'for', 'friend', 'goto', 'if', 'inline', 'int', 'long', 'mutable', 'namespace', 'new', 'operator', 'private', 'protected', 'public', 'register', 'reinterpret_cast', 'return', 'short', 'signed', 'sizeof', 'static', 'static_cast', 'struct', 'switch', 'template', 'this', 'throw', 'true', 'try', 'typedef', 'typeid', 'typename', 'union', 'unsigned', 'using', 'virtual', 'void', 'volatile', 'wchar_t', 'while', 'and', 'and_eq', 'bitand', 'bitor', 'compl', 'not', 'not_eq', 'or', 'or_eq', 'xor', 'xor_eq']$/;"	v
cppOperatorPunctuator	tokenizer.vim	/^let s:cppOperatorPunctuator = ['->*', '->', '--', '-=', '-', '!=', '!', '##', '#', '%:%:', '%=', '%>', '%:', '%', '&&', '&=', '&', '(', ')', '*=', '*', ',', '...', '.*', '.', '\/=', '\/', '::', ':>', ':', ';', '?', '[', ']', '^=', '^', '{', '||', '|=', '|', '}', '~', '++', '+=', '+', '<<=', '<%', '<:', '<<', '<=', '<', '==', '=', '>>=', '>>', '>=', '>']$/;"	v
hasPreviewWindow	complete.vim	/^let s:hasPreviewWindow = match(&completeopt, 'preview')>=0$/;"	v
hasPreviewWindowOld	complete.vim	/^let s:hasPreviewWindowOld = s:hasPreviewWindow$/;"	v
index	namespaces.vim	/^                        let index+=1$/;"	v
index	namespaces.vim	/^                let index = 0$/;"	v
item	items.vim	/^            let item.kind = omni#cpp#utils#GetCastType(item.tokens)$/;"	v
len	namespaces.vim	/^    let len = len(listResolvedNamespace)$/;"	v
listParentContext	namespaces.vim	/^    let listParentContext = keys(mapContext)$/;"	v
listResolvedNamespace	namespaces.vim	/^    let listResolvedNamespace = []$/;"	v
listTagsOfNamespace	namespaces.vim	/^        let listTagsOfNamespace = g:omni#cpp#namespaces#CacheResolve[a:namespace]$/;"	v
listTagsOfNamespace	namespaces.vim	/^        let listTagsOfNamespace = omni#common#utils#TagList('^'.a:namespace.'$')$/;"	v
listTagsOfNamespace	namespaces.vim	/^    let listTagsOfNamespace = []$/;"	v
listTmp	namespaces.vim	/^                        let listTmp = listTmp[index+1:]$/;"	v
listTmp	namespaces.vim	/^        let listTmp = []$/;"	v
mapContext	namespaces.vim	/^        let mapContext[szParentContext] = 1$/;"	v
mapContext	namespaces.vim	/^    let mapContext = {}$/;"	v
mapReorder	namespaces.vim	/^        let mapReorder[ mapCurrentContexts[key] ] = key$/;"	v
mapReorder	namespaces.vim	/^    let mapReorder = {}$/;"	v
namespaces	namespaces.vim	/^                let namespaces = ['::'] + omni#cpp#namespaces#GetListFromCurrentBuffer(startLine)$/;"	v
namespaces	namespaces.vim	/^                let namespaces = omni#cpp#namespaces#ResolveAll(namespaces)$/;"	v
namespaces	utils.vim	/^            let namespaces = [omni#cpp#utils#ExtractScope(result), '::']$/;"	v
omni	includes.vim	/^    let g:omni#cpp#includes#CACHE_INCLUDES[a:szFilePath] = listIncludes$/;"	v
omni	includes.vim	/^let g:omni#cpp#includes#CACHE_FILE_TIME = {}$/;"	v
omni	includes.vim	/^let g:omni#cpp#includes#CACHE_INCLUDES = {}$/;"	v
omni	namespaces.vim	/^        let g:omni#cpp#namespaces#CacheResolve[a:namespace] = listTagsOfNamespace$/;"	v
omni	namespaces.vim	/^        let g:omni#cpp#namespaces#CacheUsing[szFixedPath] = namespaceMap$/;"	v
omni	namespaces.vim	/^let g:omni#cpp#namespaces#CacheResolve = {}$/;"	v
omni	namespaces.vim	/^let g:omni#cpp#namespaces#CacheUsing = {}$/;"	v
omni	utils.vim	/^            let g:omni#cpp#utils#CACHE_TAG_INHERITS[szTypeInfo] = result$/;"	v
omni	utils.vim	/^let g:omni#cpp#utils#CACHE_TAG_INHERITS = {}$/;"	v
omni	utils.vim	/^let g:omni#cpp#utils#szFilterGlobalScope .= "&& (!has_key(v:val, 'enum') || (has_key(v:val, 'enum') && v:val.enum =~ '^\\\\w\\\\+$')))"$/;"	v
omni	utils.vim	/^let g:omni#cpp#utils#szFilterGlobalScope = "(!has_key(v:val, 'class') && !has_key(v:val, 'struct') && !has_key(v:val, 'union') && !has_key(v:val, 'namespace')"$/;"	v
omni	utils.vim	/^let omni#cpp#utils#expIgnoreComments = 'getline(".") =~ g:omni#cpp#utils#reIgnoreComment'$/;"	v
omni	utils.vim	/^let omni#cpp#utils#reIgnoreComment = escape('\\\/\\\/\\|\\\/\\*\\|\\*\\\/', '*\/\\')$/;"	v
omni	utils.vim	/^let omni#cpp#utils#szEscapedCharacters = ' %#'$/;"	v
parenGroup	utils.vim	/^                    let parenGroup = token.group$/;"	v
parenGroup	utils.vim	/^        let parenGroup = -1$/;"	v
popupItemResultList	complete.vim	/^let s:popupItemResultList = []$/;"	v
reCComment	tokenizer.vim	/^let s:reCComment = '\\\/\\*\\|\\*\\\/'$/;"	v
reComment	tokenizer.vim	/^let s:reComment = s:reCComment.'\\|'.s:reCppComment$/;"	v
reCppComment	tokenizer.vim	/^let s:reCppComment = '\\\/\\\/'$/;"	v
reCppKeyword	tokenizer.vim	/^let s:reCppKeyword = '\\C\\<'.join(s:cppKeyword, '\\>\\|\\<').'\\>'$/;"	v
reCppOperatorOrPunctuator	tokenizer.vim	/^let s:reCppOperatorOrPunctuator = escape(join(s:cppOperatorPunctuator, '\\|'), '*.\/^~[]')$/;"	v
reIncludeFilePart	includes.vim	/^let s:reIncludeFilePart = '\\(<\\|"\\)\\(\\f\\|\\s\\)\\+\\(>\\|"\\)'$/;"	v
rePreprocIncludeFile	includes.vim	/^let s:rePreprocIncludeFile = s:rePreprocIncludePart . s:reIncludeFilePart$/;"	v
rePreprocIncludePart	includes.vim	/^let s:rePreprocIncludePart = '\\C#\\s*include\\s*'$/;"	v
result	items.vim	/^            let result = omni#cpp#utils#CreateTypeInfo(szTypeInfo)$/;"	v
result	namespaces.vim	/^            let result.kind = 1$/;"	v
result	namespaces.vim	/^            let result.value = resolvedItem.value$/;"	v
result	namespaces.vim	/^        let result.kind = 1$/;"	v
result	namespaces.vim	/^        let result.value = listResolvedNamespace[0]$/;"	v
result	namespaces.vim	/^    let result = []$/;"	v
result	namespaces.vim	/^    let result.scope = szClassScope$/;"	v
result	utils.vim	/^                    let result = s:GetTagOfSameScope(tagList, szTmpScope)$/;"	v
result	utils.vim	/^                let result = omni#cpp#utils#GetResolvedTagItem(namespaces, omni#cpp#utils#CreateTypeInfo(result))$/;"	v
result	utils.vim	/^                let result = omni#cpp#utils#GetResolvedTagItem(namespaces, omni#cpp#utils#CreateTypeInfo(szTypeInfo))$/;"	v
result	utils.vim	/^            let result = result[:-2]$/;"	v
startLine	namespaces.vim	/^        let startLine = code.startLine$/;"	v
state	namespaces.vim	/^                    let state=1$/;"	v
state	namespaces.vim	/^                    let state=2$/;"	v
state	namespaces.vim	/^        let state = 0$/;"	v
state	utils.vim	/^                    let state=0$/;"	v
state	utils.vim	/^                    let state=1$/;"	v
state	utils.vim	/^                    let state=2$/;"	v
state	utils.vim	/^                    let state=3$/;"	v
state	utils.vim	/^                let state = 1$/;"	v
state	utils.vim	/^                let state = 2$/;"	v
state	utils.vim	/^        let state = 0$/;"	v
szAccessFilter	complete.vim	/^                                    let szAccessFilter = 'public'$/;"	v
szAccessFilter	complete.vim	/^                                    let szAccessFilter = (s:contextStack[0] == szTypeInfo)? 'all' : 'protected'$/;"	v
szAccessFilter	complete.vim	/^                        let szAccessFilter = 'public'$/;"	v
szAccessFilter	complete.vim	/^                        let szAccessFilter = (s:contextStack[0] == szTypeInfo)? 'all' : 'protected'$/;"	v
szClassScope	namespaces.vim	/^                    let szClassScope = omni#cpp#utils#ExtractTypeInfoFromTag(tagItem)$/;"	v
szClassScope	namespaces.vim	/^            let szClassScope .= join(listClassScope, '::')$/;"	v
szClassScope	namespaces.vim	/^            let szClassScope = join(listClassScope, '::')$/;"	v
szClassScope	namespaces.vim	/^    let szClassScope = '::'$/;"	v
szCmd	utils.vim	/^                let szCmd = omni#cpp#utils#ExtractCmdFromTagItem(result)$/;"	v
szCode	utils.vim	/^                let szCode = substitute(omni#cpp#utils#GetCodeFromLine(szCmd), '\\C\\<'.result.name.'\\>.*', '', 'g')$/;"	v
szCurrentWorkingDir	complete.vim	/^let s:szCurrentWorkingDir = getcwd()$/;"	v
szParentContext	namespaces.vim	/^        let szParentContext = omni#cpp#utils#ExtractScope(tagItem)$/;"	v
szResult	utils.vim	/^                    let szResult = token.value.szResult$/;"	v
szResult	utils.vim	/^                let szResult .= token.value$/;"	v
szTmpScope	utils.vim	/^                    let szTmpScope = omni#cpp#utils#SimplifyScope('::'.szScopeOfTypeInfo)$/;"	v
szTypeInfo	complete.vim	/^                            let szTypeInfo = omni#cpp#utils#ExtractTypeInfoFromTag(resolvedTagItem)$/;"	v
szTypeInfo	complete.vim	/^                    let szTypeInfo = omni#cpp#utils#ExtractTypeInfoFromTag(resolvedTagItem)$/;"	v
szTypeInfo	items.vim	/^        let szTypeInfo = s:ExtractTypeInfoFromDecl(tokens)$/;"	v
szTypeInfo	utils.vim	/^                let szTypeInfo = omni#cpp#utils#ExtractTypeInfoFromTokens(omni#cpp#tokenizer#Tokenize(szCode))$/;"	v
tagItem	namespaces.vim	/^                let tagItem = omni#cpp#utils#GetResolvedTagItem(namespaces, omni#cpp#utils#CreateTypeInfo(szClassScope))$/;"	v
tagPopupList	complete.vim	/^                        let tagPopupList = s:SearchMembers(resolvedTagItem, a:base)$/;"	v
tokens	namespaces.vim	/^        let tokens = reverse(omni#cpp#tokenizer#Tokenize(code.code[:aPos-1])[:-4])$/;"	v
tokens	utils.vim	/^        let tokens = reverse(tokens)$/;"	v
typeInfo	complete.vim	/^        let typeInfo = omni#cpp#items#ResolveItemsTypeInfo(s:contextStack, g:omni#cpp#items#data)$/;"	v
